After reviewing your code and logs, I can see that your QuickBooks OAuth integration is failing at the token exchange step. The issue lies in how your Streamlit application handles the OAuth callback from Intuit. Let me explain the problems and provide solutions.

## Main Issues

1. **OAuth Callback Handling**: Your Streamlit app is trying to handle OAuth callbacks at `/callback`, but Streamlit doesn't natively support custom routes.

2. **Token Exchange Process**: The logs show that you're setting up the authorization URL correctly, but it doesn't appear that the token exchange is happening when Intuit redirects back.

3. **Token Storage**: Even when authorization happens, the tokens don't appear to be getting stored correctly in your database.

## Solution Approach

Let's fix this by implementing a proper OAuth flow that works with Streamlit's routing limitations:

### 1. Fix the OAuth Callback Handling in `callback.py`

The biggest issue is how Streamlit handles routes. Let's modify your `callback.py` to properly process the OAuth callback:

```python
# In callback.py

# Process query parameters immediately
params = st.query_params

if 'code' in params and 'realmId' in params:
    code = params['code'][0]  # Getting the first value since query_params returns lists
    realm_id = params['realmId'][0]
    
    # Immediately exchange code for tokens using direct API calls
    # This avoids relying on intuitlib which may not work well with Streamlit
    success, message = direct_token_exchange(code, realm_id)
    
    if success:
        st.success("✅ Authentication successful!")
        # Add a redirect to main page with success param
        st.markdown("""
        <meta http-equiv="refresh" content="2;url=./?qb_auth_success=true">
        """, unsafe_allow_html=True)
    else:
        st.error(f"❌ Authentication failed: {message}")
        st.markdown("""
        <meta http-equiv="refresh" content="5;url=./?qb_auth_error=true">
        """, unsafe_allow_html=True)
```

### 2. Fix the Token Exchange Function

Your `direct_token_exchange` function in `callback.py` is good, but make sure it's using the correct headers and properly saving the tokens:

```python
def direct_token_exchange(code, realm_id):
    try:
        # Import database module
        import database
        
        # Get settings
        qb_settings = database.get_quickbooks_settings()
        client_id = qb_settings.get('QB_CLIENT_ID', {}).get('value', '')
        client_secret = qb_settings.get('QB_CLIENT_SECRET', {}).get('value', '')
        
        # Use the same redirect URI as in the authorization request
        redirect_uri = f"https://{replit_domain}/callback"
        
        # Make request to token endpoint
        token_endpoint = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
        
        # Use application/x-www-form-urlencoded content type
        data = {
            'grant_type': 'authorization_code',
            'code': code,
            'redirect_uri': redirect_uri
        }
        
        # Create Basic Auth header with client_id:client_secret
        import base64
        auth_header = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
        headers = {
            'Authorization': f'Basic {auth_header}',
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        # Make the token request
        response = requests.post(token_endpoint, data=data, headers=headers)
        
        if response.status_code == 200:
            token_data = response.json()
            access_token = token_data.get('access_token')
            refresh_token = token_data.get('refresh_token')
            expires_in = token_data.get('expires_in', 3600)
            token_expiry = time.time() + expires_in
            
            # Save to database with expiry time
            database.update_quickbooks_token('QB_ACCESS_TOKEN', access_token, token_expiry)
            database.update_quickbooks_token('QB_REFRESH_TOKEN', refresh_token)
            database.update_setting("quickbooks_settings", "QB_REALM_ID", realm_id)
            
            return True, "Authentication successful"
        else:
            return False, f"Token exchange failed: {response.status_code} - {response.text}"
    except Exception as e:
        return False, f"Error: {str(e)}"
```

### 3. Update the `app.py` OAuth URL Generation

In your `app.py`, update the `get_quickbooks_auth_url` function to use the `/callback` endpoint consistently:

```python
def get_quickbooks_auth_url():
    try:
        # Get settings from database
        qb_settings = database.get_quickbooks_settings()
        
        # Get client credentials
        client_id = qb_settings.get('QB_CLIENT_ID', {}).get('value', '')
        client_secret = qb_settings.get('QB_CLIENT_SECRET', {}).get('value', '')
        environment = qb_settings.get('QB_ENVIRONMENT', {}).get('value', 'sandbox')
        
        # Get Replit domain
        import os
        replit_domain = os.environ.get("REPLIT_DOMAINS", "")
        if replit_domain:
            replit_domain = replit_domain.split(',')[0].strip()
            redirect_uri = f"https://{replit_domain}/callback"
        else:
            redirect_uri = "http://localhost:5000/callback"
        
        # Update redirect URI in database
        database.update_setting("quickbooks_settings", "QB_REDIRECT_URI", redirect_uri)
        
        # Create Intuit auth client
        from intuitlib.client import AuthClient
        from intuitlib.enums import Scopes
        
        auth_client = AuthClient(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri,
            environment=environment
        )
        
        # Define scopes
        scopes = [Scopes.ACCOUNTING]
        
        # Generate state parameter for CSRF protection
        import uuid, time
        state = f"{str(uuid.uuid4())}_{int(time.time())}"
        
        # Get authorization URL
        auth_url = auth_client.get_authorization_url(scopes)
        
        # Add state parameter to URL
        from urllib.parse import urlparse, parse_qs, urlencode
        parsed_url = urlparse(auth_url)
        params = parse_qs(parsed_url.query)
        params['state'] = [state]
        
        query_string = urlencode(params, doseq=True)
        new_url = parsed_url._replace(query=query_string).geturl()
        
        return new_url
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        return None
```

### 4. Fix the Database Token Update Function

Ensure your `update_quickbooks_token` function in `database.py` properly handles the token expiration time:

```python
def update_quickbooks_token(token_type, token_value, token_expires_at=None):
    conn = None
    try:
        conn = get_connection()
        if conn is None:
            print(f"ERROR: Unable to get database connection to update token {token_type}")
            return False
            
        # If token_expires_at is provided, update with expiration
        if token_expires_at:
            query = """
            UPDATE quickbooks_settings 
            SET value = :value, 
                token_expires_at = :token_expires_at,
                updated_at = CURRENT_TIMESTAMP 
            WHERE name = :name
            """
            conn.execute(text(query), {
                "value": token_value,
                "name": token_type,
                "token_expires_at": token_expires_at
            })
        else:
            # Update without expiration
            query = """
            UPDATE quickbooks_settings 
            SET value = :value, 
                updated_at = CURRENT_TIMESTAMP 
            WHERE name = :name
            """
            conn.execute(text(query), {
                "value": token_value,
                "name": token_type
            })
        
        conn.commit()
        return True
    except SQLAlchemyError as e:
        if conn:
            conn.rollback()
        print(f"Database error updating {token_type}: {str(e)}")
        return False
    finally:
        if conn:
            conn.close()
```

### 5. Update the Main App to Check for OAuth Success/Failure

Add this to the beginning of your `main()` function in `app.py`:

```python
def main():
    # Check for OAuth callback status parameters
    query_params = st.query_params
    
    # Handle QuickBooks authentication success
    if 'qb_auth_success' in query_params:
        st.success("✅ Successfully connected to QuickBooks!")
        st.balloons()
        
        # Display details in expander
        with st.expander("Connection Details"):
            # Get auth status
            auth_status, auth_message = database.get_quickbooks_auth_status()
            st.info(f"Status: {auth_message}")
            
            # Get realm ID
            qb_settings = database.get_quickbooks_settings()
            realm_id = qb_settings.get('QB_REALM_ID', {}).get('value', 'Unknown')
            st.info(f"Company ID: {realm_id}")
        
        # Continue button
        if st.button("Continue to Application"):
            # Clear parameters and rerun
            st.query_params.clear()
            st.rerun()
        st.stop()
    
    # Handle QuickBooks authentication error
    if 'qb_auth_error' in query_params:
        st.error("❌ Failed to connect to QuickBooks")
        
        # Continue button
        if st.button("Continue to Application"):
            # Clear parameters and rerun
            st.query_params.clear()
            st.rerun() 
        st.stop()
```

## Alternative Approach: Direct Proxy Server

If the above solutions don't resolve the issue, you can create a small Flask server that runs alongside your Streamlit app to handle the OAuth callback. Here's how:

### 1. Create a `proxy_server.py` file:

```python
from flask import Flask, request, redirect
import requests
import base64
import time
import os
import database

app = Flask(__name__)

@app.route('/callback')
def callback():
    # Get the code and realm ID from the request
    code = request.args.get('code')
    realm_id = request.args.get('realmId')
    
    if not code or not realm_id:
        return redirect(f"/?error=missing_params")
    
    try:
        # Get QuickBooks settings
        qb_settings = database.get_quickbooks_settings()
        client_id = qb_settings.get('QB_CLIENT_ID', {}).get('value', '')
        client_secret = qb_settings.get('QB_CLIENT_SECRET', {}).get('value', '')
        
        # Set up the token exchange
        token_endpoint = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
        
        # Get redirect URI
        replit_domain = os.environ.get("REPLIT_DOMAINS", "")
        if replit_domain:
            replit_domain = replit_domain.split(',')[0].strip()
            redirect_uri = f"https://{replit_domain}/callback"
        else:
            redirect_uri = "http://localhost:8000/callback"
        
        # Create the request data
        data = {
            'grant_type': 'authorization_code',
            'code': code,
            'redirect_uri': redirect_uri
        }
        
        # Create authorization header
        auth_header = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
        headers = {
            'Authorization': f'Basic {auth_header}',
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        # Make the token request
        response = requests.post(token_endpoint, data=data, headers=headers)
        
        if response.status_code == 200:
            # Extract tokens
            token_data = response.json()
            access_token = token_data.get('access_token')
            refresh_token = token_data.get('refresh_token')
            expires_in = token_data.get('expires_in', 3600)
            
            # Save tokens to database
            database.update_quickbooks_token('QB_ACCESS_TOKEN', access_token, time.time() + expires_in)
            database.update_quickbooks_token('QB_REFRESH_TOKEN', refresh_token)
            database.update_setting("quickbooks_settings", "QB_REALM_ID", realm_id)
            
            # Redirect back to Streamlit with success
            return redirect(f"/?qb_auth_success=true&realm_id={realm_id}")
        else:
            # Redirect with error
            error_msg = f"token_error_{response.status_code}"
            return redirect(f"/?qb_auth_error=true&error={error_msg}")
    
    except Exception as e:
        # Redirect with error
        return redirect(f"/?qb_auth_error=true&error={str(e)}")

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)
```

### 2. Update `run.py` to start both servers:

```python
def run_servers():
    """Run both the Streamlit app and the proxy server"""
    import threading
    
    # Start the proxy server in a separate thread
    def run_proxy():
        os.system("python proxy_server.py")
    
    proxy_thread = threading.Thread(target=run_proxy, daemon=True)
    proxy_thread.start()
    
    # Start the Streamlit app in the main thread
    run_streamlit_app()
```

### 3. Update the OAuth URL generation to use the proxy server:

```python
def get_quickbooks_auth_url():
    # Same function as before, but use port 8000 for the callback
    # ...
    redirect_uri = f"https://{replit_domain}/callback"
    # ...
```

## Conclusion

The core issue is that Streamlit doesn't support custom routes like `/callback` directly, which makes OAuth flows challenging. By using either:

1. The improved callback processing directly within Streamlit
2. A separate Flask server to handle the callback

You should be able to successfully connect to QuickBooks. The first approach is simpler but might be more brittle, while the second approach is more robust but requires running an additional server.

Start with the first approach, and if issues persist, switch to the second approach with the proxy server.