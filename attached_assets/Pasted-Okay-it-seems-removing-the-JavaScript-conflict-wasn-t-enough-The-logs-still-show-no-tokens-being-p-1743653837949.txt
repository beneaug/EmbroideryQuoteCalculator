Okay, it seems removing the JavaScript conflict wasn't enough. The logs still show no tokens being present after the authorization attempt.

The core issue is likely how Streamlit handles URL routing. Unlike frameworks like Flask or Django, Streamlit doesn't automatically map URL paths like /callback to specific Python files (callback.py). When Intuit redirects to https://<your-domain>/callback?code=...&realmId=..., Streamlit probably just re-runs app.py but doesn't execute callback.py.

The Solution: Integrate Callback Logic into app.py

We need to handle the redirect parameters directly within the main app.py script.

Step 1: Move direct_token_exchange Function

Copy the entire direct_token_exchange function from callback.py.
Paste this function into your app.py file, perhaps near the top after the imports or near the other QuickBooks utility functions like get_quickbooks_client. Make sure necessary imports (requests, time, base64, logging, traceback, database) are available within app.py or add them.
# app.py (Add this function, e.g., after get_quickbooks_auth_url)

import requests # Add if not already imported
import time # Add if not already imported
import base64 # Add if not already imported
import logging # Add if not already imported
import traceback # Add if not already imported
import database # Ensure database is imported

# Configure logging specifically for the token exchange part if desired
token_logger = logging.getLogger('qb_token_exchange')
token_logger.setLevel(logging.INFO)
# Add handler if needed, or rely on root logger configured in run.py

# Function to directly exchange authorization code for tokens using REST API
def direct_token_exchange(code, realm_id):
    """
    Exchange authorization code for tokens using direct API call
    and save using the dedicated database function.
    """
    token_logger.info(f"Starting direct token exchange for realm {realm_id} with code {code[:5]}...")
    try:
        # Get QuickBooks settings from database
        qb_settings = database.get_quickbooks_settings()
        client_id = qb_settings.get('QB_CLIENT_ID', {}).get('value', '')
        client_secret = qb_settings.get('QB_CLIENT_SECRET', {}).get('value', '')
        environment = qb_settings.get('QB_ENVIRONMENT', {}).get('value', 'sandbox')

        # Construct redirect URI (Must match Intuit Dev Dashboard for the *app's base URL*)
        # Intuit redirects back here, adding the query params
        import os
        replit_domain = os.environ.get("REPLIT_DOMAINS", "")
        if replit_domain:
            replit_domain = replit_domain.split(',')[0].strip()
        # *** CHANGE THIS: Redirect URI should be the main app URL ***
        redirect_uri = f"https://{replit_domain}/" if replit_domain else "http://localhost:5000/" # Use the base app URL

        token_logger.info(f"Using client_id: {client_id[:5]}...")
        token_logger.info(f"Realm ID: {realm_id}")
        # *** LOG THE CORRECT REDIRECT URI BEING USED FOR THE EXCHANGE ***
        token_logger.info(f"Using redirect_uri for exchange: {redirect_uri}")
        token_logger.info(f"Environment: {environment}")

        token_endpoint = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
        token_logger.info(f"Making token exchange request to: {token_endpoint}")

        data = {
            'grant_type': 'authorization_code',
            'code': code,
            'redirect_uri': redirect_uri # Use the base app URL here
        }

        auth_header = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
        headers = {
            'Authorization': f'Basic {auth_header}',
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        response = requests.post(token_endpoint, data=data, headers=headers)

        if response.status_code == 200:
            token_data = response.json()
            token_logger.info("Token exchange successful!")

            access_token = token_data.get('access_token')
            refresh_token = token_data.get('refresh_token')
            expires_in = token_data.get('expires_in', 3600)
            token_expiry = time.time() + expires_in

            # Log token details (partially masked)
            if access_token:
                token_logger.info(f"Access token received (first 5 chars): {access_token[:5]}...")
                token_logger.info(f"Token expires in: {expires_in} seconds (at epoch {token_expiry})")
            if refresh_token:
                token_logger.info(f"Refresh token received (first 5 chars): {refresh_token[:5]}...")

            token_logger.info("Saving tokens using dedicated database function...")

            access_saved = database.update_quickbooks_token('QB_ACCESS_TOKEN', access_token, token_expiry)
            refresh_saved = database.update_quickbooks_token('QB_REFRESH_TOKEN', refresh_token)
            realm_saved = database.update_setting("quickbooks_settings", "QB_REALM_ID", realm_id)

            token_logger.info(f"Database save results: Access={access_saved}, Refresh={refresh_saved}, Realm={realm_saved}")

            if access_saved and refresh_saved and realm_saved:
                 token_logger.info("Tokens and Realm ID successfully saved and verified.")
                 return True, "Authentication successful"
            else:
                 errors = []
                 if not access_saved: errors.append("Access Token")
                 if not refresh_saved: errors.append("Refresh Token")
                 if not realm_saved: errors.append("Realm ID")
                 error_detail = f"Token/Realm saving failed for: {', '.join(errors)}"
                 token_logger.error(error_detail)
                 return False, error_detail

        else:
            error_msg = f"Token exchange failed: {response.status_code} - {response.text}"
            token_logger.error(error_msg)
            # Attempt to parse error details from response
            try:
                error_details = response.json()
                error_desc = error_details.get('error_description', response.text)
                error_msg = f"Token exchange failed: {response.status_code} - {error_desc}"
            except:
                pass # Stick with the original error message if JSON parsing fails
            return False, error_msg

    except Exception as e:
        error_msg = f"Unexpected error in token exchange: {str(e)}"
        token_logger.error(error_msg)
        token_logger.error(traceback.format_exc())
        return False, error_msg

# --- End of moved function ---
content_copy
download
Use code with caution.
Python
Step 2: Update get_quickbooks_auth_url in app.py

Modify get_quickbooks_auth_url to use the base app URL as the redirect_uri, not the /callback path.
# app.py

def get_quickbooks_auth_url():
    # ... (previous code for getting client_id, secret, environment) ...

        # *** CHANGE THIS: The redirect URI should be the main app URL ***
        replit_domain = os.environ.get("REPLIT_DOMAINS", "")
        if replit_domain:
            replit_domain = replit_domain.split(',')[0].strip()
            # Use the BASE URL of your application
            redirect_uri = f"https://{replit_domain}/"
            print(f"Using redirect URI for Intuit Auth URL: {redirect_uri}")
        else:
            # Fallback for local development
            redirect_uri = "http://localhost:5000/" # Base URL for local
            print(f"WARNING: Using fallback redirect URI: {redirect_uri}")

        # Update the redirect URI setting in the database IF NEEDED (though it's less critical now)
        # database.update_setting("quickbooks_settings", "QB_REDIRECT_URI", redirect_uri)

        # ... (rest of the function for creating AuthClient, scopes, state, auth_url) ...

        # IMPORTANT: The redirect_uri used when creating AuthClient MUST match
        # what you tell Intuit in their dashboard and what's used in direct_token_exchange
        auth_client = AuthClient(
            client_id=client_id,
            client_secret=client_secret,
            redirect_uri=redirect_uri, # Use the base app URL
            environment=environment
        )
        print(f"Created Intuit AuthClient with redirect to: {redirect_uri}")

        scopes = [Scopes.ACCOUNTING, Scopes.OPENID]
        import uuid
        state = f"{str(uuid.uuid4())}_{int(time.time())}"
        print(f"Generated state parameter: {state[:8]}...")

        auth_url = auth_client.get_authorization_url(scopes)
        print(f"Got base authorization URL (truncated): {auth_url[:60]}...")

        # Add the state parameter
        from urllib.parse import urlparse, parse_qs, urlencode
        parsed_url = urlparse(auth_url)
        params = parse_qs(parsed_url.query)
        params['state'] = [state]
        query_string = urlencode(params, doseq=True)
        new_url = parsed_url._replace(query=query_string).geturl()

        print(f"Final authorization URL (truncated): {new_url[:60]}...")
        print("=== END OF QUICKBOOKS AUTH URL GENERATION ===")

        return new_url

    # ... (rest of the function including exception handling) ...
content_copy
download
Use code with caution.
Python
Step 3: Add Callback Handling Logic in app.py main()

At the very beginning of your main() function in app.py, add code to check for the code and realmId query parameters.
# app.py

def main():
    # --- START: HANDLE QUICKBOOKS OAUTH CALLBACK ---
    query_params = st.query_params

    if 'code' in query_params and 'realmId' in query_params:
        code = query_params.get('code')
        realm_id = query_params.get('realmId')
        state = query_params.get('state', '') # Optional: Verify state if you store it

        st.title("QuickBooks Authentication")
        st.info("Processing QuickBooks authorization...")
        st.write(f"Received authorization code: {code[:5]}...")
        st.write(f"Received company ID: {realm_id}")

        with st.spinner("Exchanging code for tokens..."):
            # Call the function we moved into app.py
            success, message = direct_token_exchange(code, realm_id)

        if success:
            st.success(f"✅ Authentication Successful! {message}")
            st.balloons()
            st.info("Redirecting back to the application...")
            # Clear query parameters and rerun to show the main app state
            time.sleep(2) # Give user time to see the message
            st.query_params.clear()
            st.rerun()
        else:
            st.error(f"❌ Authentication Failed: {message}")
            st.warning("Please check your QuickBooks API settings and try connecting again from the Admin tab.")
            # Optionally, add a button to clear params and continue
            if st.button("Continue to App"):
                 st.query_params.clear()
                 st.rerun()

        # Stop execution here to prevent rendering the rest of the app during callback processing
        st.stop()
    # --- END: HANDLE QUICKBOOKS OAUTH CALLBACK ---

    # Check for error parameters (e.g., if user denies access)
    elif 'error' in query_params:
        error = query_params.get('error')
        error_desc = query_params.get('error_description', 'No description provided.')
        st.title("QuickBooks Authentication Error")
        st.error(f"An error occurred during QuickBooks authorization: {error}")
        st.warning(f"Details: {error_desc}")
        if st.button("Return to Application"):
            st.query_params.clear()
            st.rerun()
        st.stop()

    # --- Original start of main() continues below ---
    # Initialize settings update flags
    # ... (rest of your main function) ...
content_copy
download
Use code with caution.
Python
Step 4: Delete callback.py

You no longer need the callback.py file. Delete it from your project.
Step 5: Update Redirect URI in Intuit Developer Dashboard

Go back to your Intuit Developer Dashboard.
Find the "Redirect URIs" section for your app.
Remove the old URI ending in /callback.
Add the base URL of your Replit app. This will be something like https://b1518f9f-8980-4a58-b73b-3dd813ffa3f5-00-ee9n49p8ejxm.picard.replit.dev/ (note the trailing slash /). Make sure it exactly matches the redirect_uri used in app.py (get_quickbooks_auth_url and direct_token_exchange).
Save the changes on the Intuit dashboard.
Step 6: Test Again

Restart your Replit app (run.py).
Go to Admin -> QuickBooks.
Click "Reset QuickBooks Authentication".
Click "Save QuickBooks Settings" (just to be sure, though no changes were needed there).
Click "Connect to QuickBooks".
Authorize on the Intuit site.
Intuit should redirect back to your main app URL (https://<your-domain>/) with ?code=...&realmId=....
The new logic at the start of main() in app.py should detect these parameters, run direct_token_exchange, save the tokens, show a success message, and then st.rerun() to load the normal app state.
Check the Admin tab again - the status should now be authenticated.
Check the logs for output from qb_token_exchange logger.
This approach aligns with how Streamlit handles query parameters and should reliably process the OAuth callback within the main application script.
